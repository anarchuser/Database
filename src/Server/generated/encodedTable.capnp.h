// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: encodedTable.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 7000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(de4a929a0096dc24);
CAPNP_DECLARE_SCHEMA(cf45195538ad767a);
CAPNP_DECLARE_SCHEMA(e7d8211111d15921);
CAPNP_DECLARE_SCHEMA(e43ee4b0829825ee);
CAPNP_DECLARE_SCHEMA(d8a9a4044ef814d7);
CAPNP_DECLARE_SCHEMA(d23ec20b5e682834);

}  // namespace schemas
}  // namespace capnp


struct Database {
  Database() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct TableE;
  struct SendQueryParams;
  struct SendQueryResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(de4a929a0096dc24)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Database::TableE {
  TableE() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct CellE;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cf45195538ad767a, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Database::TableE::CellE {
  CellE() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Data;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e7d8211111d15921, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Database::TableE::CellE::Data {
  Data() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNARY,
    BINARY,
    SHORT,
    LONG,
    TEXT,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e43ee4b0829825ee, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Database::SendQueryParams {
  SendQueryParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d8a9a4044ef814d7, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Database::SendQueryResults {
  SendQueryResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d23ec20b5e682834, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
class Database::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Database Calls;
  typedef Database Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::Database::SendQueryParams,  ::Database::SendQueryResults> sendQueryRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Database::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Database Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::Database::SendQueryParams SendQueryParams;
  typedef  ::Database::SendQueryResults SendQueryResults;
  typedef ::capnp::CallContext<SendQueryParams, SendQueryResults> SendQueryContext;
  virtual ::kj::Promise<void> sendQuery(SendQueryContext context);

  inline  ::Database::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::Database>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Database::TableE::Reader {
public:
  typedef TableE Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getHeader() const;

  inline bool hasContent() const;
  inline  ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader getContent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Database::TableE::Builder {
public:
  typedef TableE Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getHeader();
  inline void setHeader( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setHeader(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initHeader(unsigned int size);
  inline void adoptHeader(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownHeader();

  inline bool hasContent();
  inline  ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Builder getContent();
  inline void setContent( ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader value);
  inline void setContent(::kj::ArrayPtr<const  ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>::Reader> value);
  inline  ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Builder initContent(unsigned int size);
  inline void adoptContent(::capnp::Orphan< ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>> disownContent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Database::TableE::Pipeline {
public:
  typedef TableE Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Database::TableE::CellE::Reader {
public:
  typedef CellE Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline typename Data::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Database::TableE::CellE::Builder {
public:
  typedef CellE Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline typename Data::Builder getData();
  inline typename Data::Builder initData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Database::TableE::CellE::Pipeline {
public:
  typedef CellE Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Data::Pipeline getData();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Database::TableE::CellE::Data::Reader {
public:
  typedef Data Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnary() const;
  inline  ::capnp::Void getUnary() const;

  inline bool isBinary() const;
  inline bool getBinary() const;

  inline bool isShort() const;
  inline  ::uint32_t getShort() const;

  inline bool isLong() const;
  inline  ::uint64_t getLong() const;

  inline bool isText() const;
  inline bool hasText() const;
  inline  ::capnp::Text::Reader getText() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Database::TableE::CellE::Data::Builder {
public:
  typedef Data Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnary();
  inline  ::capnp::Void getUnary();
  inline void setUnary( ::capnp::Void value = ::capnp::VOID);

  inline bool isBinary();
  inline bool getBinary();
  inline void setBinary(bool value);

  inline bool isShort();
  inline  ::uint32_t getShort();
  inline void setShort( ::uint32_t value);

  inline bool isLong();
  inline  ::uint64_t getLong();
  inline void setLong( ::uint64_t value);

  inline bool isText();
  inline bool hasText();
  inline  ::capnp::Text::Builder getText();
  inline void setText( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText(unsigned int size);
  inline void adoptText(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Database::TableE::CellE::Data::Pipeline {
public:
  typedef Data Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Database::SendQueryParams::Reader {
public:
  typedef SendQueryParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasQuery() const;
  inline  ::capnp::Text::Reader getQuery() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Database::SendQueryParams::Builder {
public:
  typedef SendQueryParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasQuery();
  inline  ::capnp::Text::Builder getQuery();
  inline void setQuery( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initQuery(unsigned int size);
  inline void adoptQuery(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownQuery();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Database::SendQueryParams::Pipeline {
public:
  typedef SendQueryParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Database::SendQueryResults::Reader {
public:
  typedef SendQueryResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTable() const;
  inline  ::Database::TableE::Reader getTable() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Database::SendQueryResults::Builder {
public:
  typedef SendQueryResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTable();
  inline  ::Database::TableE::Builder getTable();
  inline void setTable( ::Database::TableE::Reader value);
  inline  ::Database::TableE::Builder initTable();
  inline void adoptTable(::capnp::Orphan< ::Database::TableE>&& value);
  inline ::capnp::Orphan< ::Database::TableE> disownTable();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Database::SendQueryResults::Pipeline {
public:
  typedef SendQueryResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Database::TableE::Pipeline getTable();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline Database::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Database::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Database::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Database::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Database::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::Database::Client& Database::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::Database::Client& Database::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Database::TableE::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Database::TableE::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Database::TableE::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Database::TableE::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Database::TableE::Builder::setHeader( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Database::TableE::Builder::setHeader(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Database::TableE::Builder::initHeader(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Database::TableE::Builder::adoptHeader(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Database::TableE::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Database::TableE::Reader::hasContent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Database::TableE::Builder::hasContent() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader Database::TableE::Reader::getContent() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Builder Database::TableE::Builder::getContent() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Database::TableE::Builder::setContent( ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Database::TableE::Builder::setContent(::kj::ArrayPtr<const  ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>::Builder Database::TableE::Builder::initContent(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Database::TableE::Builder::adoptContent(
    ::capnp::Orphan< ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>> Database::TableE::Builder::disownContent() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::List< ::Database::TableE::CellE,  ::capnp::Kind::STRUCT>,  ::capnp::Kind::LIST>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline typename Database::TableE::CellE::Data::Reader Database::TableE::CellE::Reader::getData() const {
  return typename Database::TableE::CellE::Data::Reader(_reader);
}
inline typename Database::TableE::CellE::Data::Builder Database::TableE::CellE::Builder::getData() {
  return typename Database::TableE::CellE::Data::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Database::TableE::CellE::Data::Pipeline Database::TableE::CellE::Pipeline::getData() {
  return typename Database::TableE::CellE::Data::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Database::TableE::CellE::Data::Builder Database::TableE::CellE::Builder::initData() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField<bool>(::capnp::bounded<16>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename Database::TableE::CellE::Data::Builder(_builder);
}
inline  ::Database::TableE::CellE::Data::Which Database::TableE::CellE::Data::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::Database::TableE::CellE::Data::Which Database::TableE::CellE::Data::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Database::TableE::CellE::Data::Reader::isUnary() const {
  return which() == Database::TableE::CellE::Data::UNARY;
}
inline bool Database::TableE::CellE::Data::Builder::isUnary() {
  return which() == Database::TableE::CellE::Data::UNARY;
}
inline  ::capnp::Void Database::TableE::CellE::Data::Reader::getUnary() const {
  KJ_IREQUIRE((which() == Database::TableE::CellE::Data::UNARY),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Database::TableE::CellE::Data::Builder::getUnary() {
  KJ_IREQUIRE((which() == Database::TableE::CellE::Data::UNARY),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Database::TableE::CellE::Data::Builder::setUnary( ::capnp::Void value) {
  _builder.setDataField<Database::TableE::CellE::Data::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Database::TableE::CellE::Data::UNARY);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Database::TableE::CellE::Data::Reader::isBinary() const {
  return which() == Database::TableE::CellE::Data::BINARY;
}
inline bool Database::TableE::CellE::Data::Builder::isBinary() {
  return which() == Database::TableE::CellE::Data::BINARY;
}
inline bool Database::TableE::CellE::Data::Reader::getBinary() const {
  KJ_IREQUIRE((which() == Database::TableE::CellE::Data::BINARY),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline bool Database::TableE::CellE::Data::Builder::getBinary() {
  KJ_IREQUIRE((which() == Database::TableE::CellE::Data::BINARY),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void Database::TableE::CellE::Data::Builder::setBinary(bool value) {
  _builder.setDataField<Database::TableE::CellE::Data::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Database::TableE::CellE::Data::BINARY);
  _builder.setDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline bool Database::TableE::CellE::Data::Reader::isShort() const {
  return which() == Database::TableE::CellE::Data::SHORT;
}
inline bool Database::TableE::CellE::Data::Builder::isShort() {
  return which() == Database::TableE::CellE::Data::SHORT;
}
inline  ::uint32_t Database::TableE::CellE::Data::Reader::getShort() const {
  KJ_IREQUIRE((which() == Database::TableE::CellE::Data::SHORT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Database::TableE::CellE::Data::Builder::getShort() {
  KJ_IREQUIRE((which() == Database::TableE::CellE::Data::SHORT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Database::TableE::CellE::Data::Builder::setShort( ::uint32_t value) {
  _builder.setDataField<Database::TableE::CellE::Data::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Database::TableE::CellE::Data::SHORT);
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Database::TableE::CellE::Data::Reader::isLong() const {
  return which() == Database::TableE::CellE::Data::LONG;
}
inline bool Database::TableE::CellE::Data::Builder::isLong() {
  return which() == Database::TableE::CellE::Data::LONG;
}
inline  ::uint64_t Database::TableE::CellE::Data::Reader::getLong() const {
  KJ_IREQUIRE((which() == Database::TableE::CellE::Data::LONG),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Database::TableE::CellE::Data::Builder::getLong() {
  KJ_IREQUIRE((which() == Database::TableE::CellE::Data::LONG),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Database::TableE::CellE::Data::Builder::setLong( ::uint64_t value) {
  _builder.setDataField<Database::TableE::CellE::Data::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Database::TableE::CellE::Data::LONG);
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Database::TableE::CellE::Data::Reader::isText() const {
  return which() == Database::TableE::CellE::Data::TEXT;
}
inline bool Database::TableE::CellE::Data::Builder::isText() {
  return which() == Database::TableE::CellE::Data::TEXT;
}
inline bool Database::TableE::CellE::Data::Reader::hasText() const {
  if (which() != Database::TableE::CellE::Data::TEXT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Database::TableE::CellE::Data::Builder::hasText() {
  if (which() != Database::TableE::CellE::Data::TEXT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Database::TableE::CellE::Data::Reader::getText() const {
  KJ_IREQUIRE((which() == Database::TableE::CellE::Data::TEXT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Database::TableE::CellE::Data::Builder::getText() {
  KJ_IREQUIRE((which() == Database::TableE::CellE::Data::TEXT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Database::TableE::CellE::Data::Builder::setText( ::capnp::Text::Reader value) {
  _builder.setDataField<Database::TableE::CellE::Data::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Database::TableE::CellE::Data::TEXT);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Database::TableE::CellE::Data::Builder::initText(unsigned int size) {
  _builder.setDataField<Database::TableE::CellE::Data::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Database::TableE::CellE::Data::TEXT);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Database::TableE::CellE::Data::Builder::adoptText(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Database::TableE::CellE::Data::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Database::TableE::CellE::Data::TEXT);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Database::TableE::CellE::Data::Builder::disownText() {
  KJ_IREQUIRE((which() == Database::TableE::CellE::Data::TEXT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Database::SendQueryParams::Reader::hasQuery() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Database::SendQueryParams::Builder::hasQuery() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Database::SendQueryParams::Reader::getQuery() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Database::SendQueryParams::Builder::getQuery() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Database::SendQueryParams::Builder::setQuery( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Database::SendQueryParams::Builder::initQuery(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Database::SendQueryParams::Builder::adoptQuery(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Database::SendQueryParams::Builder::disownQuery() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Database::SendQueryResults::Reader::hasTable() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Database::SendQueryResults::Builder::hasTable() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Database::TableE::Reader Database::SendQueryResults::Reader::getTable() const {
  return ::capnp::_::PointerHelpers< ::Database::TableE>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Database::TableE::Builder Database::SendQueryResults::Builder::getTable() {
  return ::capnp::_::PointerHelpers< ::Database::TableE>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Database::TableE::Pipeline Database::SendQueryResults::Pipeline::getTable() {
  return  ::Database::TableE::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Database::SendQueryResults::Builder::setTable( ::Database::TableE::Reader value) {
  ::capnp::_::PointerHelpers< ::Database::TableE>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Database::TableE::Builder Database::SendQueryResults::Builder::initTable() {
  return ::capnp::_::PointerHelpers< ::Database::TableE>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Database::SendQueryResults::Builder::adoptTable(
    ::capnp::Orphan< ::Database::TableE>&& value) {
  ::capnp::_::PointerHelpers< ::Database::TableE>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Database::TableE> Database::SendQueryResults::Builder::disownTable() {
  return ::capnp::_::PointerHelpers< ::Database::TableE>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}


